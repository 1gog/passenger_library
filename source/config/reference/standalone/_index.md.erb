**Table of contents**

<ol class="toc-container"><li>Loading...</li></ol>

## Server options

### `--address` / "address"

<table class="table table-bordered table-striped">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --address <em>HOST</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"address": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>0.0.0.0</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Instructs Passenger to listen for requests on the given IP address. This means that Passenger will only be able to accept requests that are sent to that IP address.

The IP address may be an IPv4 address or an IPv6 address. If you want to listen on a Unix domain socket, use [`--socket` / "socket_file"](#--socket-socket_file).

The default is to bind to 0.0.0.0, which means that Passenger can accept requests from any IPv4 address. If you use Passenger in a [reverse proxy setup](<%= url_for "/deploy/standalone/reverse_proxy.html" %>) then you should bind Passenger to 127.0.0.1, which means that only processes on the local host can access Passenger, not the public Internet.


### `--port` / "port"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --port <em>NUMBER</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"port": <em>integer</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>3000</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Instructs Passenger to listen for requests on the given TCP port number. Only has effect if you did not use [`--socket` / "socket_file"](#--socket-socket_file).


### `--socket` / "socket_file"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --socket <em>FILE</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"socket_file": <em>string</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Instructs Passenger to listen for requests on a Unix domain socket, not on a TCP socket. Unix domain sockets are a special kind of socket provided by the operating system, that are only usable on the local computer, not over the Internet. In return for this restricted functionality, they are highly optimized and much faster than TCP sockets.

A Unix domain socket appears as a file on the filesystem.

There are almost no web browsers and HTTP clients that support Unix domain sockets. Unix domain sockets are mainly useful if you plan on using Passenger in a [reverse proxy setup](<%= url_for "/deploy/standalone/reverse_proxy.html" %>), where you configure a reverse proxy like Nginx, running on the local machine, to forward requests to Passenger over a Unix domain socket.


### `--ssl` / "ssl"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --ssl</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ssl": true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Passenger does not enable SSL</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
</table>

Instructs Passenger to accept (encrypted) HTTPS requests on its socket, instead of (unencrypted) HTTP requests.

If you want Passenger to be able to listen for HTTP and HTTPS at the same time (although on different port numbers), then please use  [`--ssl-port` / "ssl_port"](#--ssl-port-ssl_port). It is not possible to make passenger listen for HTTP and HTTPS on the same port.

If this option is set, you must also set [`--ssl-certificate` / "ssl_certificate"](#--ssl-certificate-ssl_certificate) and [`--ssl-certificate-key` / "ssl_certificate_key"](#--ssl-certificate-key-ssl_certificate_key) to the SSL certificate and key files, respectively.

### `--ssl-certificate` / "ssl_certificate"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start [...] --ssl-certificate <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ssl_certificate": <em>string</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
</table>

Sets the SSL certificate to use.

This option only has effect if [`--ssl` / "ssl"](#--ssl-ssl) is set.


### `--ssl-certificate-key` / "ssl_certificate_key"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start [...] --ssl-certificate-key <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ssl_certificate_key": <em>string</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
</table>

Sets the SSL certificate key to use.

This option only has effect if [`--ssl` / "ssl"](#--ssl-ssl) is set.


### `--ssl-port` / "ssl_port"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start [...] --ssl-port NUMBER</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ssl_port": <em>integer</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
</table>

Instructs Passenger to listen for HTTPS requests on the given port number, while letting [the normal port number](#--port-port) listen for regular unecrypted HTTP requests.

For example, if you run the following, the Passenger will listen for HTTP requests on port 3000, while also listening for HTTPS requests on port 3005:

    passenger start --ssl --ssl-certificate ... --ssl-certificate-key ... --ssl-port 3005

This option only has effect if [`--ssl` / "ssl"](#--ssl-ssl) is set.

<div class="note">
  When in <a href="<%= url_for "/deploy/standalone/mass_deployment.html" %>">Mass Deployment mode</a>, you will probably want to set a default <code>ssl_port</code> instead of leaving this option unspecified. This is because some of your apps may contain a Passengerfile.json that contains <code>"ssl": true</code>, while others do not. In such a situation, this means that some apps want to listen for HTTPS requests on the default port, while others want to listen for unencrypted HTTP requests, which is a contradiction and causes Passenger to abort.
</div>


### `--daemonize` / "daemonize"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --daemonize</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"daemonize": true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Passenger runs in the foreground</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Instructs Passenger to daemonize into the background.


### `--user` / "user"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --user USERNAME</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"user": <em>string</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Instructs Passenger to drop its privilege to that of the given user as soon as Passenger has setup the socket. This only works if Passenger was started with root privileges.

If this option is not given, then Passenger runs as the user that invoked it.


### `--log-file` / "log_file"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --log-file <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"log_file": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>See description</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Log to the given log file.

The default behavior is as follows:

 1. If there is a `log` subdirectory, log to `log/passenger.XXX.log`.
 2. Otherwise, log to `passenger.XXX.log`.

In both cases, XXX is the [port number](#--port-port) that Passenger listens on.

If [`--socket` / "socket_file"](#--socket-socket_file) is set, then the default log filename does not contain the `.XXX` part.


### `--pid-file` / "pid_file"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --pid-file <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"pid_file": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>See description</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Store the Passenger PID in the given PID file.

The default behavior is as follows:

 1. If there is a `tmp/pids` subdirectory, use the PID file `tmp/pids/passenger.XXX.pid`.
 2. Otherwise, use the PID file `passenger.XXX.pid`.

In both cases, XXX is the [port number](#--port-port) that Passenger listens on.

If [`--socket` / "socket_file"](#--socket-socket_file) is set, then the default PID filename does not contain the `.XXX` part.


### `--instance-registry-dir` / "instance_registry_dir"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --instance-registry-dir <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"instance_registry_dir": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>/tmp or /var/run/passenger-instreg</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Specifies the directory that Passenger should use for registering its current instance.

When Passenger starts up, it creates a temporary directory inside the _instance registry directory_. This temporary directory is called the _instance directory_. It contains all sorts of files that are important to that specific running Passenger instance, such as Unix domain socket files so that all the different Passenger processes can communicate with each other. Command line tools such as `passenger-status` use the files in this directory in order to query Passenger's status.

It is therefore important that, while Passenger is working, the instance directory is never removed or tampered with. However, the default path for the instance registry directory is the system's temporary directory, and some systems may run background jobs that periodically clean this directory. If this happens, and the files inside the instance directory are removed, then it will cause Passenger to malfunction: Passenger won't be able to communicate with its own processes, and you will see all kinds of connection errors in the log files. This malfunction can only be recovered from by restarting Apache. You can prevent such cleaning background jobs from interfering by setting this option to a different directory.

This option is also useful if the partition that the temporary directory lives on doesn't have enough disk space.

The instance directory is automatically removed when Nginx shuts down.

#### Default value

The default value for this option is as follows:

 * If you are on Red Hat and CentOS, and installed Passenger through the RPMs provided by Phusion, then the default value is `/var/run/passenger-instreg`.
 * Otherwise, the default value is the value of the `$TMPDIR` environment variable. Or, if `$TMPDIR` is not set, `/tmp`.

#### Note regarding command line tools

Some Passenger command line administration tools, such as `passenger-status`, must know what Passenger's instance registry directory is in order to function properly. You can pass the directory through the `PASSENGER_INSTANCE_REGISTRY_DIR` or the `TMPDIR` environment variable.

For example, if you set 'PassengerInstanceRegistryDir' to '/my_temp_dir', then invoke `passenger-status` after you've set the `PASSENGER_INSTANCE_REGISTRY_DIR`, like this:

~~~bash
export PASSENGER_INSTANCE_REGISTRY_DIR=/my_temp-dir
sudo -E passenger-status
~~~

Notes regarding the above example:

 * The -E option tells 'sudo' to preserve environment variables.
 * If Passenger is installed through an RVM Ruby, then you must use `rvmsudo` instead of `sudo`.


### `--data-buffer-dir` / "data_buffer_dir"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --data-buffer-dir <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"data_buffer_dir": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>See description</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

By default, Passenger buffers large web application responses. This prevents [slow HTTP clients](<%= url_for "/indepth/slow_clients.html" %>) from blocking web applications by reading responses very slowly. This feature is also known as "real-time disk-backed response buffering".

By default, such buffers are stored in the directory given by the `$TMPDIR` environment variable, or (if `$TMPDIR` is not set) the `/tmp` directory. This configuration option allows you to specify a different directory.

Changing this option is especially useful if the partition that the default directory lives on doesn't have enough disk space.

If you've specified such a directory (as opposed to using Passenger's default) then you *must* ensure that this directory exists.


## Application loading options

### `--environment` / "environment"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --environment NAME</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"environment": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>development</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

This option sets the value of the following environment variables:

 * `RAILS_ENV`
 * `RACK_ENV`
 * `WSGI_ENV`
 * `NODE_ENV`
 * `PASSENGER_APP_ENV`

Some web frameworks, for example Rails and Connect.js, adjust their behavior according to the value in one of these environment variables.


### `--ruby` / "ruby"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --ruby <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"ruby": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>The Ruby interpreter that was used for starting Passenger Standalone</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.7</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Specifies the Ruby interpreter to use for serving Ruby web applications.


### `--python` / "python"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --python <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"python": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>The first "python" command in <a href="<%= url_for "/indepth/environment_variables.html" %>#the-path-environment-variable">the $PATH environment variable</a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.7</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Specifies the Python interpreter to use for serving Python web applications.


### `--nodejs` / "nodejs"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --nodejs <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"nodejs": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>The first "node" command in <a href="<%= url_for "/indepth/environment_variables.html" %>#the-path-environment-variable">the $PATH environment variable</a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.7</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Specifies the Node.js/io.js comand to use for serving Node.js/io.js web applications.

Passenger's support for Node.js and io.js are the same. If you want to use io.js instead of Node.js, simply set this option to your iojs binary.


### `--meteor-app-settings` / "meteor_app_settings"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --meteor-app-settings <em>PATH_TO_JSON_SETTINGS_FILE</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"meteor_app_settings": <em>string</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>5.0.7</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

When using a Meteor application in non-bundled mode, use this option to specify a JSON file with settings for the application. The `meteor run` command will be run with the `--settings` parameter set to this option.

Note that this option is not intended to be used for bundled/packaged Meteor applications. When running bundled/packaged Meteor applications on Passenger, you should set the `METEOR_SETTINGS` environment variable.


### `--rackup`

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --rackup <em>RELATIVE_PATH</em></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Consider application a Ruby app, and use the given Rackup file instead of the default `config.ru`. The filename is relative to the application directory.

The corresponding Passengerfile.json looks as follows:

~~~json
{
  "app_type": "rack",
  "startup_file": "(your value here)"
}
~~~


### `--app-type` / "app_type"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --app-type <em>NAME</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"app_type": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td><a href="<%= url_for "/indepth/app_autodetection/standalone/index.html" %>">Autodetected</a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.25</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

By default, Passenger [autodetects](<%= url_for "/indepth/app_autodetection/standalone/index.html" %>) the type of the application, e.g. whether it's a Ruby, Python, Node.js or Meteor app. If it's unable to autodetect the type of the application (e.g. because you've specified a custom [`--startup-file` / "startup_file"](#--startup-file-startup_file)) then you can use this option to force Passenger to recognize the application as a specific type.

Allowed values are:

<table class="table table-bordered table-striped">
  <thead>
    <th>Value</th>
    <th>Application type</th>
  </thead>
  <tbody>
    <% SUPPORTED_APP_TYPES.each do |spec| %>
      <tr>
        <td><%= spec[:type] %></td>
        <td><%= spec[:name] %></td>
      </tr>
    <% end %>
  </tbody>
</table>

#### Config file example

Use server.js as the startup file (entry point file) for your Node.js application, instead of the default app.js:

~~~json
{
  "app_type": "node",
  "startup_file": "server.js"
}
~~~


### `--startup-file` / "startup_file"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --startup-file <em>RELATIVE_PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"startup_file": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td><a href="<%= url_for "/indepth/app_autodetection/standalone/index.html" %>">Autodetected</a></td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.25</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

This option specifies the startup file that Passenger should use when loading the application. This path is relative to the application directory.

Every application has a *startup file* or *entry point file*: a file where the application begins execution. Some languages have widely accepted conventions about how such a file should be called (e.g. Ruby, with its `config.ru`). Other languages have somewhat-accepted conventions (e.g. Node.js, with its `app.js`). In these cases, Passenger reuses these conventions, and executes applications through those files.

Other languages have no conventions at all, and so Passenger invents one (e.g. Python WSGI with `passenger_wsgi.py`).

Here's a list of the language-specific conventions that Passenger accepts:

<table class="table table-striped table-bordered">
  <thead>
    <tr>
      <th>Language</th>
      <th>Passenger convention</th>
    </tr>
  </thead>
  <tbody>
    <% SUPPORTED_APP_TYPE_CONVENTIONS.each do |spec| %>
      <tr>
        <td><%= spec[:name] %></td>
        <td><%= spec[:startup_file] %></td>
      </tr>
    <% end -%>
  </tbody>
</table>

Sometimes you might not want to adhere to the convention that Passenger accepts. For example, on Node.js, you might want to use `server.js` as the startup file instead of the default `app.js`. With this option, you can customize the startup file to any file you like.

<div class="note">
  If you set this option, you <strong>must</strong> also set <a href="#--app-type-app_type"><code>--app-type</code> / "app_type"</a>, otherwise Passenger doesn't know what kind of application it is.
</div>

#### Config file example

~~~json
{
  "app_type": "node",
  "startup_file": "server.js"
}
~~~


### `--spawn-method` / "spawn_method"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --spawn-method <em>NAME</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"spawn_method": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>
      For Ruby apps: <code>smart</code><br>
      For other apps: <code>direct</code>
    </td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

This option controls whether Passenger spawns applications directly, or using a prefork copy-on-write mechanism. The [spawn methods guide](<%= url_for "/indepth/spawn_methods.html" %>) explains this in detail.


### `--static-files-dir` / "static_files_dir"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --static-files-dir <em>PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"static_files_dir": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td><em>app_dir</em>/public</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.25</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx</td>
  </tr>
</table>

By default, Passenger automatically serves static files in the application's `public` subdirectory. Your application is offloaded from having to serve static files. In case your static files are not located in `public` but somewhere else, then use this option to specify the location.


### `--restart-dir` / "restart_dir"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --restart-dir <em>RELATIVE_PATH</em></td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"restart_dir": <em>string</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td><em>app_dir</em>/tmp</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

As described in [Restarting applications](<%= url_for "/admin/#{integration_mode_type}/restart_app.html" %>), Passenger checks the file `tmp/restart.txt` in the application directory to determine whether it should restart the application. Sometimes it may be desirable for Passenger to look in a different directory instead. This option allows you to customize the directory in which `restart.txt` is searched for.

You can either set it to an absolute directory, or to a directory relative to the application directory.

#### Example 1: default behavior

Passenger will check for /apps/foo/public/tmp/restart.txt:

    cd /apps/foo
    passenger start

#### Example 2: absolute path

An absolute filename is given. Passenger will check for /restart_files/bar/restart.txt:

    cd /apps/bar
    passenger start --restart-dir /restart_files/bar

#### Example 3: relative path

A relative filename is given. Passenger will check for /apps/baz/restart_files/restart.txt.

    cd /apps/baz
    passenger start --restart-dir restart_files


### `--friendly-error-pages`, `--no-friendly-error-pages` / "friendly_error_pages"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>
      passenger start --friendly-error-pages<br>
      passenger start --no-friendly-error-pages
    </td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"friendly_error_pages": <em>boolean</em></td>
  </tr>
  <tr>
    <th>Default</th>
    <td>
      <p>
        <em>When <a href="#--environment-environment"><code>--environment</code> / "environment"</a> is <code>staging</code> or <code>production</code>:</em><br>
        Friendly error pages are on
      </p>
      <p>
        <em>Otherwise:</em><br>
        Friendly error pages are off
      </p>
    </td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.42</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Passenger can display friendly error pages whenever an application fails to start. This friendly error page presents the startup error message, some suggestions for solving the problem, a backtrace and a dump of the environment variables.

This feature is very useful during application development and useful for less experienced system administrators, but the page might reveal potentially sensitive information, depending on the application. For this reason, friendly error pages are disabled by default when [--environment / "environment"](#--environment-environment) is set to `staging` or `production`, but enabled by default otherwise.

You can use this option to explicitly enable or disable this feature. `--friendly-error-pages` always enables friendly error pages, and `--no-friendly-error-pages` always disables friendly error pages. Similarly, the `"friendly_error_pages": boolean` config option always enables or disables friendly error pages.


### `--load-shell-envvars` / "load_shell_envvars"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --load-shell-envvars</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"load_shell_envvars": true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Disabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>4.0.42</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

Enables or disables the loading of shell environment variables before spawning the application.

If this option is turned on, and the user's shell is `bash`, then applications are loaded by running them with `bash -l -c`. If this option is turned off, applications are loaded by running them directly from the `Passenger core` process.


### `--debugger` / "debugger"

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <th>Command line syntax</th>
    <td>passenger start --debugger</td>
  </tr>
  <tr>
    <th>Config file syntax</th>
    <td>"debugger": true</td>
  </tr>
  <tr>
    <th>Default</th>
    <td>Disabled</td>
  </tr>
  <tr>
    <th>Since</th>
    <td>3.0.0</td>
  </tr>
  <tr>
    <th>Engines</th>
    <td>nginx, builtin</td>
  </tr>
</table>

<div class="note">
  At this time, this feature is supported for Ruby applications only.
</div>

Turns support for application debugging on or off. In case of Ruby applications, turning this option on will cause them to load the `ruby-debug` gem (when on Ruby 1.8), the `debugger` gem (when on Ruby 1.9) or the `byebug` gem (when on Ruby >= 2.0). If you're using Bundler, you should add this to your Gemfile:

~~~ruby
gem 'ruby-debug', :platforms => :ruby_18
gem 'debugger', :platforms => :ruby_19
gem 'byebug', :platforms => :ruby_20
~~~

Once debugging is turned on, you can use the command `passenger-irb --debug <PID>` to attach an debugging console to the application process with the given PID. Attaching will succeed once the application process executes a `debugger` command.
